{"$message_type":"diagnostic","message":"hard linking files in the incremental compilation cache failed. copying files instead. consider moving the cache directory to a file system which supports hard linking in session dir `/media/thomas/disk thomas/programation/Rust/sym_rustic/target/debug/incremental/simplification_tests-0depudvfbot97/s-h8z29tapyd-0hbqcmw-working`","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: hard linking files in the incremental compilation cache failed. copying files instead. consider moving the cache directory to a file system which supports hard linking in session dir `/media/thomas/disk thomas/programation/Rust/sym_rustic/target/debug/incremental/simplification_tests-0depudvfbot97/s-h8z29tapyd-0hbqcmw-working`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `complex` found for enum `Expression` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"tests/simplification_tests.rs","byte_start":2790,"byte_end":2797,"line_start":98,"line_end":98,"column_start":44,"column_end":51,"is_primary":true,"text":[{"text":"        assert!(expr.is_equal(&Expression::complex(","highlight_start":44,"highlight_end":51}],"label":"variant or associated item not found in `Expression`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `Expression` consider using one of the following associated functions:\nast::complex::<impl Expression>::complex_conjugate\nExpression::integer\nExpression::rational\nExpression::subtraction\nand 28 others","code":null,"level":"note","spans":[{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1375,"byte_end":1411,"line_start":65,"line_end":65,"column_start":5,"column_end":41,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1482,"byte_end":1527,"line_start":69,"line_end":69,"column_start":5,"column_end":50,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1602,"byte_end":1668,"line_start":73,"line_end":73,"column_start":5,"column_end":71,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs","byte_start":803,"byte_end":867,"line_start":21,"line_end":21,"column_start":5,"column_end":69,"is_primary":true,"text":[{"text":"    pub fn complex_conjugate(expr: Expression) -> Option<Expression> {","highlight_start":5,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a method `is_complex` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs","byte_start":178,"byte_end":210,"line_start":7,"line_end":7,"column_start":5,"column_end":37,"is_primary":true,"text":[{"text":"    pub fn is_complex(&self) -> bool {","highlight_start":5,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"tests/simplification_tests.rs","byte_start":2790,"byte_end":2797,"line_start":98,"line_end":98,"column_start":44,"column_end":51,"is_primary":true,"text":[{"text":"        assert!(expr.is_equal(&Expression::complex(","highlight_start":44,"highlight_end":51}],"label":null,"suggested_replacement":"Complex","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `complex` found for enum `Expression` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtests/simplification_tests.rs:98:44\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m98\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert!(expr.is_equal(&Expression::complex(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `Expression`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: if you're trying to build a new `Expression` consider using one of the following associated functions:\u001b[0m\n\u001b[0m      ast::complex::<impl Expression>::complex_conjugate\u001b[0m\n\u001b[0m      Expression::integer\u001b[0m\n\u001b[0m      Expression::rational\u001b[0m\n\u001b[0m      Expression::subtraction\u001b[0m\n\u001b[0m      and 28 others\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs:65:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs:21:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn complex_conjugate(expr: Expression) -> Option<Expression> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `is_complex` with a similar name, but with different arguments\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs:7:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn is_complex(&self) -> bool {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a variant with a similar name (notice the capitalization difference)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m98\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        assert!(expr.is_equal(&Expression::\u001b[0m\u001b[0m\u001b[38;5;10mComplex\u001b[0m\u001b[0m(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `complex` found for enum `Expression` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"tests/simplification_tests.rs","byte_start":3573,"byte_end":3580,"line_start":123,"line_end":123,"column_start":44,"column_end":51,"is_primary":true,"text":[{"text":"        assert!(expr.is_equal(&Expression::complex(","highlight_start":44,"highlight_end":51}],"label":"variant or associated item not found in `Expression`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `Expression` consider using one of the following associated functions:\nast::complex::<impl Expression>::complex_conjugate\nExpression::integer\nExpression::rational\nExpression::subtraction\nand 28 others","code":null,"level":"note","spans":[{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1375,"byte_end":1411,"line_start":65,"line_end":65,"column_start":5,"column_end":41,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1482,"byte_end":1527,"line_start":69,"line_end":69,"column_start":5,"column_end":50,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1602,"byte_end":1668,"line_start":73,"line_end":73,"column_start":5,"column_end":71,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs","byte_start":803,"byte_end":867,"line_start":21,"line_end":21,"column_start":5,"column_end":69,"is_primary":true,"text":[{"text":"    pub fn complex_conjugate(expr: Expression) -> Option<Expression> {","highlight_start":5,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a method `is_complex` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs","byte_start":178,"byte_end":210,"line_start":7,"line_end":7,"column_start":5,"column_end":37,"is_primary":true,"text":[{"text":"    pub fn is_complex(&self) -> bool {","highlight_start":5,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"tests/simplification_tests.rs","byte_start":3573,"byte_end":3580,"line_start":123,"line_end":123,"column_start":44,"column_end":51,"is_primary":true,"text":[{"text":"        assert!(expr.is_equal(&Expression::complex(","highlight_start":44,"highlight_end":51}],"label":null,"suggested_replacement":"Complex","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `complex` found for enum `Expression` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtests/simplification_tests.rs:123:44\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m123\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert!(expr.is_equal(&Expression::complex(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `Expression`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: if you're trying to build a new `Expression` consider using one of the following associated functions:\u001b[0m\n\u001b[0m      ast::complex::<impl Expression>::complex_conjugate\u001b[0m\n\u001b[0m      Expression::integer\u001b[0m\n\u001b[0m      Expression::rational\u001b[0m\n\u001b[0m      Expression::subtraction\u001b[0m\n\u001b[0m      and 28 others\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs:65:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs:21:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn complex_conjugate(expr: Expression) -> Option<Expression> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `is_complex` with a similar name, but with different arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs:7:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn is_complex(&self) -> bool {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a variant with a similar name (notice the capitalization difference)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m123\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        assert!(expr.is_equal(&Expression::\u001b[0m\u001b[0m\u001b[38;5;10mComplex\u001b[0m\u001b[0m(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `complex` found for enum `Expression` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"tests/simplification_tests.rs","byte_start":7830,"byte_end":7837,"line_start":265,"line_end":265,"column_start":44,"column_end":51,"is_primary":true,"text":[{"text":"        assert!(expr.is_equal(&Expression::complex(","highlight_start":44,"highlight_end":51}],"label":"variant or associated item not found in `Expression`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `Expression` consider using one of the following associated functions:\nast::complex::<impl Expression>::complex_conjugate\nExpression::integer\nExpression::rational\nExpression::subtraction\nand 28 others","code":null,"level":"note","spans":[{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1375,"byte_end":1411,"line_start":65,"line_end":65,"column_start":5,"column_end":41,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1482,"byte_end":1527,"line_start":69,"line_end":69,"column_start":5,"column_end":50,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1602,"byte_end":1668,"line_start":73,"line_end":73,"column_start":5,"column_end":71,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs","byte_start":803,"byte_end":867,"line_start":21,"line_end":21,"column_start":5,"column_end":69,"is_primary":true,"text":[{"text":"    pub fn complex_conjugate(expr: Expression) -> Option<Expression> {","highlight_start":5,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a method `is_complex` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs","byte_start":178,"byte_end":210,"line_start":7,"line_end":7,"column_start":5,"column_end":37,"is_primary":true,"text":[{"text":"    pub fn is_complex(&self) -> bool {","highlight_start":5,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"tests/simplification_tests.rs","byte_start":7830,"byte_end":7837,"line_start":265,"line_end":265,"column_start":44,"column_end":51,"is_primary":true,"text":[{"text":"        assert!(expr.is_equal(&Expression::complex(","highlight_start":44,"highlight_end":51}],"label":null,"suggested_replacement":"Complex","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `complex` found for enum `Expression` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtests/simplification_tests.rs:265:44\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert!(expr.is_equal(&Expression::complex(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `Expression`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: if you're trying to build a new `Expression` consider using one of the following associated functions:\u001b[0m\n\u001b[0m      ast::complex::<impl Expression>::complex_conjugate\u001b[0m\n\u001b[0m      Expression::integer\u001b[0m\n\u001b[0m      Expression::rational\u001b[0m\n\u001b[0m      Expression::subtraction\u001b[0m\n\u001b[0m      and 28 others\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs:65:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs:21:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn complex_conjugate(expr: Expression) -> Option<Expression> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `is_complex` with a similar name, but with different arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs:7:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn is_complex(&self) -> bool {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a variant with a similar name (notice the capitalization difference)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        assert!(expr.is_equal(&Expression::\u001b[0m\u001b[0m\u001b[38;5;10mComplex\u001b[0m\u001b[0m(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `complex` found for enum `Expression` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"tests/simplification_tests.rs","byte_start":8320,"byte_end":8327,"line_start":281,"line_end":281,"column_start":44,"column_end":51,"is_primary":true,"text":[{"text":"        assert!(expr.is_equal(&Expression::complex(","highlight_start":44,"highlight_end":51}],"label":"variant or associated item not found in `Expression`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `Expression` consider using one of the following associated functions:\nast::complex::<impl Expression>::complex_conjugate\nExpression::integer\nExpression::rational\nExpression::subtraction\nand 28 others","code":null,"level":"note","spans":[{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1375,"byte_end":1411,"line_start":65,"line_end":65,"column_start":5,"column_end":41,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1482,"byte_end":1527,"line_start":69,"line_end":69,"column_start":5,"column_end":50,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1602,"byte_end":1668,"line_start":73,"line_end":73,"column_start":5,"column_end":71,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs","byte_start":803,"byte_end":867,"line_start":21,"line_end":21,"column_start":5,"column_end":69,"is_primary":true,"text":[{"text":"    pub fn complex_conjugate(expr: Expression) -> Option<Expression> {","highlight_start":5,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a method `is_complex` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs","byte_start":178,"byte_end":210,"line_start":7,"line_end":7,"column_start":5,"column_end":37,"is_primary":true,"text":[{"text":"    pub fn is_complex(&self) -> bool {","highlight_start":5,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"tests/simplification_tests.rs","byte_start":8320,"byte_end":8327,"line_start":281,"line_end":281,"column_start":44,"column_end":51,"is_primary":true,"text":[{"text":"        assert!(expr.is_equal(&Expression::complex(","highlight_start":44,"highlight_end":51}],"label":null,"suggested_replacement":"Complex","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `complex` found for enum `Expression` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtests/simplification_tests.rs:281:44\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m281\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert!(expr.is_equal(&Expression::complex(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `Expression`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: if you're trying to build a new `Expression` consider using one of the following associated functions:\u001b[0m\n\u001b[0m      ast::complex::<impl Expression>::complex_conjugate\u001b[0m\n\u001b[0m      Expression::integer\u001b[0m\n\u001b[0m      Expression::rational\u001b[0m\n\u001b[0m      Expression::subtraction\u001b[0m\n\u001b[0m      and 28 others\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs:65:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs:21:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn complex_conjugate(expr: Expression) -> Option<Expression> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `is_complex` with a similar name, but with different arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs:7:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn is_complex(&self) -> bool {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a variant with a similar name (notice the capitalization difference)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m281\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        assert!(expr.is_equal(&Expression::\u001b[0m\u001b[0m\u001b[38;5;10mComplex\u001b[0m\u001b[0m(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `complex` found for enum `Expression` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"tests/simplification_tests.rs","byte_start":10297,"byte_end":10304,"line_start":342,"line_end":342,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"            Expression::complex(","highlight_start":25,"highlight_end":32}],"label":"variant or associated item not found in `Expression`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `Expression` consider using one of the following associated functions:\nast::complex::<impl Expression>::complex_conjugate\nExpression::integer\nExpression::rational\nExpression::subtraction\nand 28 others","code":null,"level":"note","spans":[{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1375,"byte_end":1411,"line_start":65,"line_end":65,"column_start":5,"column_end":41,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1482,"byte_end":1527,"line_start":69,"line_end":69,"column_start":5,"column_end":50,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs","byte_start":1602,"byte_end":1668,"line_start":73,"line_end":73,"column_start":5,"column_end":71,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs","byte_start":803,"byte_end":867,"line_start":21,"line_end":21,"column_start":5,"column_end":69,"is_primary":true,"text":[{"text":"    pub fn complex_conjugate(expr: Expression) -> Option<Expression> {","highlight_start":5,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a method `is_complex` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs","byte_start":178,"byte_end":210,"line_start":7,"line_end":7,"column_start":5,"column_end":37,"is_primary":true,"text":[{"text":"    pub fn is_complex(&self) -> bool {","highlight_start":5,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"tests/simplification_tests.rs","byte_start":10297,"byte_end":10304,"line_start":342,"line_end":342,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"            Expression::complex(","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":"Complex","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `complex` found for enum `Expression` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mtests/simplification_tests.rs:342:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m342\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Expression::complex(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `Expression`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: if you're trying to build a new `Expression` consider using one of the following associated functions:\u001b[0m\n\u001b[0m      ast::complex::<impl Expression>::complex_conjugate\u001b[0m\n\u001b[0m      Expression::integer\u001b[0m\n\u001b[0m      Expression::rational\u001b[0m\n\u001b[0m      Expression::subtraction\u001b[0m\n\u001b[0m      and 28 others\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/mod.rs:65:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs:21:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn complex_conjugate(expr: Expression) -> Option<Expression> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `is_complex` with a similar name, but with different arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/media/thomas/disk thomas/programation/Rust/sym_rustic/src/ast/complex.rs:7:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn is_complex(&self) -> bool {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a variant with a similar name (notice the capitalization difference)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m342\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            Expression::\u001b[0m\u001b[0m\u001b[38;5;10mComplex\u001b[0m\u001b[0m(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 5 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 5 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0599`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0599`.\u001b[0m\n"}
